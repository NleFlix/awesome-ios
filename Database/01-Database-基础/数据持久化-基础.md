---

title: 数据持久化-基础
date: 2015-10-19 
desc: iOS 开发

---

这篇文章将会介绍数据持久化的 4 种方式：NSUserDefaults,NSFileManager,NSCoding+NSKeyedArchiver。

<!--more-->

### NSUserDefaults

Cocoa 会为每个 app 自动创建一个文件，我们可以用它来存储一些较简单的数据，如音效等应用设置之类的少量信息。NSUserDefaults 本质上是以 Key-Value 形式存成 plist 文件，放在 /Library/Preferences/{Bundle Identifier}.plist 目录下，这个文件是不安全的，所以**不要用 NSUserDefaults 来存储密码之类的敏感信息 **。

NSUserDefaults 是一个单例，它支持保存的数据类型有 :NSNumber,NSString, NSDate, NSArray, NSDictionary, BOOL.

#### 写入数据

```
[[NSUserDefaults standardUserDefaults] setObject:_label.text forKey:@"name"];
[[NSUserDefaults standardUserDefaults] synchronize];
```

#### 读取数据

```
NSString * aStr = [[NSUserDefaults standardUserDefaults] objectForKey:@"name"];
```

值得注意的是：NSUserDefaults 存储的对象全是不可变的，例如，如果我想要存储一个 NSMutableArray 对象，我必须先创建一个不可变数组 :

```
NSMutableArray *mutableArray = [NSMutableArray arrayWithObjects:@"123",@"234", nil];
NSArray * array = [NSArray arrayWithArray:mutableArray];
[[NSUserDefaults standardUserDefaults] setObject:array forKey:@"name"];
[[NSUserDefaults standardUserDefaults] synchronize];
```

取出数据也一样：

```
NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:[[NSUserDefaults standardUserDefaults] objectForKey:@"name"]];
```

### NSFileManager

上面提到 NSUserDefaults 可以存成 Plist 文件，只是 Apple 帮我们封装好了读写方法而已 (事实上我们自己实现这个方法也很简单)。NSUserDefaults 的缺陷是存储只能是 Library/Preferences/<Application BundleIdentifier>.plist 这个文件，如果我们要自己写一个 Plist 文件呢？ 使用 NSFileManger 可以很容易办到。

如果你存储的数据是 Plist 文件支持的类型，直接用 NSFileManager 的 writToFile 接口就可以写入一个 plist 文件了。Plist 文件支持的数据格式有 :NSString,NSNumber, Boolean, NSDate,NSData,NSArray 和 NSDictionary. 其中，Boolean 格式事实上以 [NSNumber numberOfBool:YES/NO]; 这样的形式表示。

#### 获取路径：

```
NSFileManager *fileManager = [NSFileManager defaultManager];

//Library 目录路径 :NSLibraryDirectory, Cache 目录路径 :NSCachesDirectory
NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
// 等同于以下操作
//NSString * documentsPath = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents"];
NSString *directoryPath = [documentsPath stringByAppendingPathComponent:@"file"];
```

#### 在上面的路径下创建目录：createDirectoryAtPath

```
if (![fileManager fileExistsAtPath:directoryPath]) {
	[fileManager createDirectoryAtPath:directoryPath withIntermediateDirectories:NO attributes:nil error:nil];
}］
```

#### 在上面的目录下创建文件：createFileAtPath

```
[fileManager createFileAtPath:[documentsPath stringByAppendingString:@"/text.plist"] contents:data attributes:nil];

// 获取创建的该文件的路径
filePath = [NSString stringWithFormat:@"%@%@",documentsPath,@"test.plist"];
```

#### 写数据到文件：writeToFile

```
NSDictionary *dictionary = @{@"key":@"value"};
dictionary writeToFile:filePath atomically:YES];
```

#### 读取文件的属性：attributesOfItemAtPath
例如，读取文件的创建日期：

```
NSDate *creationDate = nil;
if ([fileManager fileExistsAtPath:filePath]) {
	NSDictionary *attributes = [fileManager attributesOfItemAtPath:filePath error:nil];
	creationDate = attributes[NSFileCreationDate];
}
```

#### 删除文件：removeItemAtPath

```
NSError *error = nil;
if (![fileManager removeItemAtPath:filePath error:&error]) {
	NSLog(@"[Error] %@ (%@)", error, filePath);
}
```

### NSKeyedArchiver/NSKeyedUnarchiver

上面介绍的两种方法，通常仅支持常用数据类型，但是不支持自定义的数据类型，不过 Cocoa 提供了 NSCoding 和 NSKeyArchiver 两个工具类，可以把我们自定义的对象编码成二进制数据流，然后存进文件里面，如果要使用这种方式进行存储，首先自定义的对象要继承 NSCoding 的 delegate。

NSCoding 是一个简单的协议，有两个方法：-initWithCoder: 和 encodeWithCoder:。遵循 NSCoding 协议的类可以被序列化和反序列化，这样可以归档到磁盘上或分发到网络上。

```
@interface Book : NSObject <NSCoding>
@property NSString *author;
@property NSUInteger price;
@end

@implementation Book
#pragma mark - NSCoding
- (id)initWithCoder:(NSCoder *)decoder {
	self = [super init];
	if (!self) {
		return nil;
	}
	self.author = [decoder decodeObjectForKey:@"author"];
	self.price = [decoder decodeIntegerForKey:@"price"];
	return self;
}

- (void)encodeWithCoder:(NSCoder *)encoder {
	[encoder encodeObject:self.author forKey:@"author"];
	[encoder encodeInteger:self.price forKey:@"price"];
}

@end
```

如上，NSCoding 主要是样板文件。每个属性用属性名作为 key，编码或解码成一个对象或者类型。这样，我们就定义了一个可以使用 NSCoding 进行编码的数据对象。

（[Mantle](https://github.com/github/Mantle) 是一个意在减少写 NSCoding 样板文件的类库，可以看看）

Archiving （归档）：

```
Book *books = [Book alloc] init];
// 归档至目录
[NSKeyedArchiver archiveRootObject:books toFile:@"/path/to/archive"];
// 归档至二进制数据
NSData *data = [NSKeyedArchiver archivedDataWithRootObject:books];
```

Unarchiving （解档）：

```
// 从目录解档
[NSKeyedUnarchiver unarchiveObjectWithFile:@"/path/to/archive"];
// 从文件解档
Book *book = [NSKeyedUnarchiver unarchiveObjectWithData:data];
```

除了归档到文件，还可以归档到 NSUserDefaults。
```
NSData *data = [NSKeyedArchiver archivedDataWithRootObject:books];
[[NSUserDefaults standardUserDefaults] setObject:data forKey:@"books"];
```

Unarchiving：
```
NSData *data = [[NSUserDefaults standardUserDefaults] objectForKey:@"books"];
NSArray *books = [NSKeyedUnarchiver unarchiveObjectWithData:data];
```

所以其实使用 NSCoding 和 NSKeyedArchiver 事实上也是写入和读取文件，只不过对复杂对象进行了编码使得文件支持更多数据类型而已。



