
这篇文章的示例代码你可以在 [这里](https://github.com/jieyuanz/ios_demo/blob/master/iosLearningDemo/iosLearningDemo/Memory/JJMemoryViewController.m) 找到。

在讲内存管理之前，我们需要先理解 heap 和 stack 的概念。

在理解 heap 和 stack 的概念之前，我们需要先理解指针的概念。

<!--more-->

### 指针

指针最早是在 C 语言中出现的，指针可以简单地理解为内存的地址。后来众多面向对象的语言例如 Java，Objective-C 也包含了这个概念，但 Java，Objective-C 上的指针实际上是受限制的指针，之所以说“受限制”，是因为不能进行指针运算（比如 p + 1 指向下一个元素之类的）。虽然缺少了灵活性，但却大大减少了程序出错的概率。你可以把 Java，Objective-C 上的指针理解为“引用”。不过，在下面的讨论，我们仍然以指针这个名称来说明。

#### 位，字节......

在讲指针之前，先普及一些小的知识点，比如位，字节，变量类型等。

位（bit），就是电路中的逻辑门，有 0 和 1 两种状态，计算机的内存中由数以亿万计的位组成，例如 00000000000000011111111....(亿万个0或1)，但是一个位只能表示两种状态，所以它最多只能表示 0 和 1 两个数，所以单独的位意义不大。

所以计算机把 8 个位合并为一个字节（byte）。

```
    00000000 00000000 00000000 00000000 00000000 00000000 ....
        |       |        |         |       |        |
        0     	1        2         3       4        5    ....
```

如上，我们把每 8 个位合并为一个字节，每个字节都有一个编号，我们把这些编号称之为地址，类似于我们家的门牌号就是我们家的地址。

> 字节是如何编号的呢？有没有想过这个问题？

也就是说一个字节有 256 种组合方式， 256 种组合方式刚好足够用来表示 26 个英文字母及其相应的大小写，标点符号，0～9，我们把这些称之为符号，即 character。

> 注意，我们上面所指的 0 ～ 9 指的是字符的概念，而不是指具体的数字。

因此， C 语言中定义了一种类型，char 类型，置占一个字节。

#### 为什么需要指针

想象一下如果没有指针，我们的程序应该怎么写？

给一个指针取地址符，意思就是指针的指针，与C、C++中的概念是一致的。 

```

              Memory address    Object
              --------------    ---------
              0
              1
              2
              3
              4
              ...
pointer ----> 10523             myObject1
              10524
              ...

```

char c; //栈上分配
char *p = new char[3]; //堆上分配，将地址赋给了p;

在 编译器遇到第一条指令时，计算其大小，然后去查找当前栈的空间是大于所需分配的空间大小，如果这时栈内空间大于所申请的空间，那么就为其分配
内存空间，注 意：在这里，内存空间的分配是连续的，是接着上次分配结束后进行分配的．如果栈内空间小于所申请的空间大小，
那么这时系统将揭示栈溢出，并给出相应的异常信息。
编译器遇到第二条指令时，由于p是在栈上分配的，所以在为p分配内在空间时和上面的方法一样，但当遇到new关 键字，那么编译器都知道，
这是用户申请的动态内存空间，所以就会转到堆上去为其寻找空间分配．大家注意：堆上的内存空间不是连续的，
它是由相应的链表将其 空间区时的内在区块连接的，所以在接到分配内存空间的指定后，它不会马上为其分配相应的空间，
而是先要计算所需空间，然后再到遍列整个堆（即遍列整个链的 节点），将第一次遇到的内存块分配给它．
最后再把在堆上分配的字符数组的首地址赋给p.，这个时候，大家已经清楚了，p中现在存放的是在堆中申请的字符数组的首地址，
也就是在堆中申请的数组的地址现在被赋给了在栈上申请的指针变量p

### 内存区域

heap 和 stack 是内存管理的两个概念。这里指的不是数据结构上面的堆与栈，这里指的是内存的分配的两个区域：堆区和栈区。（不过这两者之间确实是有相似之处）。

iOS 中某个 app 使用的内存不是一段连续的统一分配空间，而是分布在不同的内存区域，如下：

栈区（stack）：一个线程会分配一个 stack，当一个函数被调用时，例如 app 最开始运行函数 main()  ，一个 stack frame (栈帧) 就会被压到 stack 里。里面包含这个函数涉及的参数 , 局部变量 , 返回地址等相关信息。当执行第二个函数时，又一个 stack frame 会被压到 stack 里。当函数返回后 , 这个栈帧就会被销毁。而且类似数据结构中的 stack ，栈区是一种后进先出（LIFO ）结构 。这一切都是自动的，我们不需要管理栈区变量的内存；栈区地址从高到低分配。

堆区（heap）：我们使用 alloc/new/copy/mutableCopy 创建一个对象时，堆区就会分配一段内存，这部分内存需要我们进行管理，简单来讲 ARC 时代就是通过我们主动声明对象创建的内存管理语义（strong，weak，copy，assign 等），然后编译器在编译的时候自动添加 retain、release、autorelease 等方法，这些方法会通过一种叫作“引用计数”的方式进行内存管理，具体我们后面再讲。堆区的地址是从低到高分配。

全局区 / 静态区（static）：包括两个部分：全局未初始化区（BSS 区） 、全局初始化区（数据区）。也就是说，全局区 / 静态区 在内存中是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域；eg：int a ; 未初始化的。int a = 10; 已初始化的。

常量区：常量字符串就是放在这里。

代码区：存放 App 二进制代码，代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。

![](https://ws3.sinaimg.cn/large/006tNc79gy1fj7iam4mc1j30db0epa9z.jpg)

每个 Objective-C 对象都是指向某块内存数据的指针，所以在声明变量时，类型后面要跟一个“*”字符：

```
NSString *pointerVariable = @"someString";
```
pointerVariable 作为一个局部变量，它是栈上的一个指针变量，@"someString" 是堆上的内存对象，pointerVariable 变量内存放着堆上对象的内存地址。

### 为什么是 Stack 和 Heap？

首先所有的 Objective-C 对象都是分配在 heap 的。在 OC 最典型的内存分配与初始化就是这样的。

```
NSObject *obj = [[NSObject alloc] init];
```

一个对象在 alloc 的时候，就在 Heap 分配了内存空间。
stack 对象通常有速度的优势，而且不会发生内存泄露问题。那么为什么 OC 的对象都是分配在 heap 而不是 stack 呢？
原因在于：

- stack 对象的生命周期所导致的问题。例如一旦函数返回，则所在的 stack frame 就会被摧毁。那么此时返回的对象也会一并摧毁。这个时候我们去 retain 这个对象是无效的。因为整个 stack frame 都已经被摧毁了。简单而言，就是 stack 对象的生命周期不适合 Objective-C 的引用计数内存管理方法。
- stack 对象不够灵活（LIFO），不具备足够的扩展性。创建时长度已经是固定的 , 而 stack 对象的拥有者也就是所在的 stack frame.

### stack 和 heap 的工作原理

栈区（stack）：栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。有 2 种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 alloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

堆区（heap）：系统使用一个链表来维护所有已经分配的内存空间，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

