---
title: 内存管理-内存优化
date: 2015-06-05
desc: iOS 开发
---

前面的文章讲述了 ARC 以及 ARC 下内存泄漏问题，通常呢，前面讲到的那些点都做到了，一般不会有什么内存泄漏的问题。

不过，另外一个问题是，没有内存泄漏问题了，那内存占用过多如何解决和避免呢？要知道，如果 App 占用了系统过多的使用内存，系统会根据情况把 App 直接 kill，所以，内存占用问题也是一个需要关心的点。下面我们总结一些内存优化的小技巧。

<!--more-->

### 留意内存警告

通常一个应用程序会包含多个 view controllers，当从 A 跳转到另一个 B 时，之前的 A 只是不可见状态，并不会立即被清理掉，而是保存在内存中，以便下一次的快速显现。

当出现内存警告时，系统会发出 UIApplicationDidReceiveMemoryWarningNotification 的通知，所以，我们可以监听这个 UIApplicationDidReceiveMemoryWarningNotification，并做相应处理。同时，所有在内存中的 view controllers 也会调用 didReceiveMemoryWarning 方法，所以，我们也可以在 view controllers 做相应处理。

其实内存警告有时候不一定是你 App 的问题，内存警告是一个全局的概念，指的是你的手机的内存资源占用情况。所以，内存问题可能是你刚刚在运行的游戏 App 造成的，也许你的 App 并没有占用太多的内存，这时候还是会收到内存警告的问题。

不过，当收到内存警告的时候：我们还是应该释放一些资源，尤其是图片等占用内存多的资源，等需要的时候再进行重建。不过，你要确保释放的资源必须对当前类没有造成太大的影响。例如，你可以使用 Lazy Allocation（懒加载）模式调用对象，这样我们把对象直接 set nil 即可。

```
- (void)didReceiveMemoryWarning{
    self.imageArray = nil;
}

- (NSArray *)imageArray{
    if (!_imageArray) {
        _imageArray = @[[UIImage imageNamed:@"large_image1"],[UIImage imageNamed:@"large_image2"],[UIImage imageNamed:@"large_image3"],[UIImage imageNamed:@"large_image4"]];
    }
    return _imageArray;
}
```

或者，把内存中的对象移到文件缓存中，不过，这种做法也有系统 IO 的开销，通常我们只针对内存占用较大的对象这样处理。通常，图片问题是内存警告处理的主要点，可以优先处理图片问题。

例如，我们看 SDImageCache 在收到内存警告时的处理 ，它也会把对象清除掉。下次从网络或文件中读取即可。

```
@interface AutoPurgeCache : NSCache
@end

@implementation AutoPurgeCache

- (instancetype)init {
    self = [super init];
    if (self) {
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(removeAllObjects) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];    }
    return self;
}

- (void)dealloc {
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidReceiveMemoryWarningNotification object:nil];
}
@end
```

### 使用 autoreleasepool 降低内存峰值

#### 关于 autorelease

在前面的《内存管理-什么是ARC?》一文中，我们讲过 autorelease 这个概念。

```
- (NSString *)temp{
	NSString *tmp = @"A";// 计数为 1
	return [tmp autorelease];
}
```

字面上理解：自动释放。那么这个自动的时机是什么时候呢？首先，肯定不是 temp 函数调用结束的时候释放，这样 autorelease 就没有意义了。
答案是：tmp 对象在出了作用域之后，会被添加到最近一次创建的 autoreleasepool 即自动释放池中，并会在当前的 runloop 迭代结束时释放。

#### autoreleasepool

这个 autoreleasepool 的创建方法如下：

```
@autoreleasepool{
	//注意，可以嵌套使用。
}
```

就是这么的 easy。在作用域的结尾处，即右括号处，所有 autoreleasepool 中的对象都会被清理掉。

我们知道 main.m 中有一个 autoreleasepool ，那么 tmp 对象是被放到这个自动释放池吗？

```
int main(int argc, char * argv[]) {
@autoreleasepool {
    return UIApplicationMain(argc, argv, nil∂ç
    NSStringFromClass([AppDelegate class]));
}
```

答案是否定的。这个 autoreleasepool 块的运行范围是整个 app 的生命周期，这个时候才执行清理工作显然没有意义。（你可能会想那为什么 main 函数还会创建这个 autoreleasepool？那是因为 UIApplicationMain 中也有对象需要被放进自动释放池中，这个池可以理解为最外围捕捉自动释放对象所用的池）。在一次完整的运行循环结束之前，会被销毁。

回到前面说的，这个最近一次创建的 autoreleasepool 是什么时间创建的？答案是 runloop （即运行循环）检测到事件并启动后，就会创建自动释放池。

<div class="tip">

注意，自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如：自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。
但对于 blockOperation 和 invocationOperation 这种默认的Operation 或者 GCD ，系统已经帮我们封装好了，每次执行事件循环时，就会将其清理，所以不需要手动创建自动释放池。

</div>

#### 使用 autoreleasepool 避免内存峰值

那么为什么在 ARC 时代还需要使用自动释放池呢？其中一个原因就是为了避免内存峰值，比如说，我有一个很大的For 循环，里面不断读入较大的文件。其实每迭代一次，资源都已经用完了（就是说我用好了，还你），不需要再用了，这个时候就可以释放了，但是自动释放池要等线程执行下一次事件循环时才会清空，所以，在这个 for 循环期间，程序所占的内存就会持续上涨，这就增大了内存的峰值。

例如下面这个例子，每次 for 循环产生临时变量，占用的内存空间是十分可观的：

```
for (int i = 0; i < 100000; i++) {
    NSNumber *num = [NSNumber numberWithInt:i];
    NSString *str = [NSString stringWithFormat:@"%d ", i];
    NSString *getMemoryUsage = [NSString stringWithFormat:@"%@%@", num, str];
    [memoryUsageList1 addObject:getMemoryUsage];
}
```

所以我们可以通过下面这种方案来解决：

```
for (int i = 0; i < 100000; i++) {
    @autoreleasepool {
        NSNumber *num = [NSNumber numberWithInt:i];
        NSString *str = [NSString stringWithFormat:@"%d ", i];
        NSString *getMemoryUsage = [NSString stringWithFormat:@"%@%@", num, str];
        [memoryUsageList1 addObject:getMemoryUsage];
    }
}
```

每执行一次 for 循环，都会清空 for 循环中产生的临时变量，而不是等到某个事件循环时才清空，所以可以有效避免内存峰值。

#### MRC 下的 autoreleasepool

MRC 下 autoreleasepool 是这么写的，权当了解一些。

```
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
NSString* str = [[[NSString alloc] initWithString:@"tutuge"] autorelease];
[pool drain];
```

#### autoreleasepool 的其他 tips：

使用容器的 block 版本的枚举器时，内部会自动添加一个 AutoreleasePool：

```
[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    // 这里被一个局部 autoreleasepool包围着
}];
```

#### autoreleasepool 的原理

autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成:

- objc_autoreleasepoolPush
- objc_autoreleasepoolPop
- objc_autorelease

看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。

### 图片的读取问题

```
UIImage *image1 = [UIImage imageNamed:@"smallImage"];
NSString *path =  [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@"bigImage.png"];
UIImage *image2 = [UIImage imageWithContentsOfFile:@"bigImage"];
```

上面这两种写法有什么区别吗？[UIImage imageNamed:] 只适合与 UI 界面中小的贴图的读取，而一些比较大的资源文件应该尽量避免使用这个接口。直接读取文件路径 [UIImage imageWithContentsOfFile] 来解决图片的读取问题

- 对于第一种，是带缓存机制的，如果频繁读取小文件，用它就只需要读取一次就好，但是缺点就是如果使用大图片会常驻内存，对于降低内存峰值是不利的。
- 对于第二种方法，不带缓存机制，适合使用大图片，使用完就释放

注意，使用 imageNamed 获取的图片可以放在 Assets.xcassets 中，然后只要传入图片名称即可，系统会自动适配 2x 和 3x 的图片。

而 imageWithContentsOfFile 获取的图片，参数不可以只是图片的名称，必须是图片的文件路径，同时，图片不能放在 Assets.xcassets，否则获取不到图片的路径。放在 Assets.xcassets 中的图片只能通过imageNamed:方式去加载。因为 Assets.xcassets中 的图片根本就不在 MainBundle 里面，而是被系统打包统一打入到 ASSets.car 中。

留意下获取 path 的方法:

```
NSString *path =  [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@"bigImage.png"];
```

如果是下面这么写也是可以的，但是就没办法适配 2x 和 3x 的图片了。

```
NSString *path = [[NSBundle mainBundle]pathForResource:@"bigImage@2x" ofType:"png"];
```

### NSData 的读取问题

取一个几十 M 的大数据文件，如果采用 NSData 的 dataWithContentsOfFile: 方法，将会耗尽 iOS 的内存。其实这个是可以改善的。
NSData 还有一个API：

```
+ (id)dataWithContentsOfFile:(NSString *)path options:(NSDataReadingOptions)readOptionsMask error:(NSError **)errorPtr;
```

其中 NSDataReadingOptions 可以附加一个参数 NSDataReadingMappedIfSafe 参数。使用这个参数后，iOS 就不会把整个文件全部读取的内存了，而是将文件映射到进程的地址空间中，这么做并不会占用实际内存。这样就可以解决内存满的问题。

```
    NSString *path = @"test";
    NSError *error = nil;
    NSData *data1 = [[NSData alloc] initWithContentsOfFile:path options:NSDataReadingMappedIfSafe error:&error];
```

对于体积很大文件，使用内存映射方式读取将会减少大量内存占用。什么是文件内存映射呢？

文件内存映射是指把一个文件的内容映射到进程的内存虚拟地址空间中，这个实际上并没有为文件内容分配物理内存。实际上就相当于将内存地址值指向文件的磁盘地址。如果对这些内存进行读写，实际上就是对文件在磁盘上内容进行读写。

