---
title: 内存管理-内存泄漏
date: 2015-06-03
desc: iOS 开发
---

即便有了 ARC，如果不注意使用的话，也是有可能导致内存泄露的。内存泄漏问题一直是项目开发中的一大问题，下面我们列举出几种常见的内存泄漏场景和解决方案。

### 内存泄漏场景

#### 两个类循环引用

JJMemoryObject.h:
```
@class JJMemoryViewController;
@interface JJMemoryObject : NSObject<NSCopying>
@property (nonatomic, strong) JJMemoryViewController *vc;
@end
```
JJMemoryViewController.m
```
#import "JJMemoryViewController.h"
#import "JJMemoryObject.h"

@implementation JJMemoryViewController{
    JJMemoryObject *_object;
}
```

如上的代码，JJMemoryObject 强引用了 JJMemoryViewController，JJMemoryViewController 也强引用了 JJMemoryObject，这样就导致了循环引用，ARC 无法回收这两个对象，从而导致内存泄露。

可以把其中一个 strong 修改为 weak:

```
@property (nonatomic, weak) JJMemoryViewController *vc;
```

或者在其中一个类中的 dealloc 做以下操作：
```
- (void)dealloc{
    _object = nil;
    NSLog(@"JJMemoryViewController dealloc");
}
```

#### delegate 循环引用问题

delegate 循环引用问题比较基础，原理和两个类循环引用一样，这里特地拿出来讲是因为 delegate 比较常用。具体可看下面的示例图。只需注意将代理属性修饰为 weak 即可。

```
@protocol JJMemoryObjectDelegate <NSObject>
@end

@interface JJMemoryObject : NSObject<NSCopying>
@property (nonatomic, weak) id<JJMemoryObjectDelegate> delegate;
```

![](https://ws1.sinaimg.cn/large/006tNc79gy1fj7jqx0vtfj30gr0710so.jpg)

weak 在这里还可以表达一种非拥有关系，即 delegate 属性并不是创建它的类所拥有的，而是实现 delegate 协议的类所拥有的。

#### Block

我们从一个例子开始讲起。
有这样一个场景：在类 JJMemoryObject 中有一个获取 data 的回调 Block：

JJMemoryObject.h:
```
typedef void(^JJMemoryObjectCompletionHandler)(NSData *data);
@interface JJMemoryObject : NSObject<NSCopying>
- (void)loadDataWithCompletionHandler:(JJMemoryObjectCompletionHandler)completion;
@end
```

JJMemoryObject.m:
```
#import "JJMemoryObject.h"
@interface JJMemoryObject ()
@property (nonatomic, copy) JJMemoryObjectCompletionHandler completion;
@end
@implementation JJMemoryObject
- (void)loadDataWithCompletionHandler:(JJMemoryObjectCompletionHandler)completion{
    _completion = completion;//注意，这里编译器会自动执行 copy 操作
}
//假设类调用了这个方法，通知给 block
- (void)p_requestCompleted{
    if (_completion) {
        NSData *data = nil;
        _completion(data);
    }
}
```

某个类中使用网络工具类发送请求并处理回调,JJMemoryViewController.m
```
@implementation JJMemoryViewController{
    JJMemoryObject *_object;
    NSData *_loadData;
}

- (void)downloadData{
    [_object loadDataWithCompletionHandler:^(NSData *data) {
        _loadData = data;
    }];
}
```

很明显在使用 block 的过程中形成了循环引用：self 持有 _object， _object 持有 block，block 持有 self。三者形成循环引用，内存泄露。

下面这种写法也会造成循环引用，不过只有 _object 持有 block；block 持有 self 一个循环。

JJMemoryObject.m
```
+ (id)shareInstance{
    static dispatch_once_t onceToken;
    static JJMemoryObject *object = nil;
    dispatch_once(&onceToken, ^{
        object = [[JJMemoryObject alloc]init];
    });
    return object;
}

+ (void)easyLoadDataWithCompletionHandler:(JJMemoryObjectCompletionHandler)completion{
    JJMemoryObject *object = [JJMemoryObject shareInstance];
    object.completion = completion;//_object 持有 block
}
```

JJMemoryViewController.m
```
- (void)easyDownloadData{
    [JJMemoryObject easyLoadDataWithCompletionHandler:^(NSData *data) {
        _loadData = data;//block 持有 self
    }];
}
```

解决方案有两种：

1:将 block 回调完成之后，将 block 对象置为 nil，消除引用，打破循环引用：

JJMemoryObject.m
```
- (void)p_requestCompleted{
    if (_completion) {
        NSData *data = nil;
        _completion(data);
//        _completion = nil;
    }
}

```

2:将强引用转换成弱引用，打破循环引用。

```
- (void)downloadData{
    __weak typeof(self) weakSelf = self;
    [_object loadDataWithCompletionHandler:^(NSData *data) {
        __strong typeof(weakSelf) strongSelf = weakSelf;
        strongSelf->_loadData = data;
    }];
}
```
如上的代码，我们先创建一个由  __weak  修饰符修饰的局部变量，这里变量指向当前的 self。 其中的 typeof(self) 使用 typeof() 这个方法拿到 self 的类类型。（这里直接写 JJMemoryObject 也 OK）。weakSelf 的  __weak  修饰符表示变量被 block 引用之后会作为 block 的局部变量从栈中复制到堆中，ARC 会管理这个 block 中所有局部变量的内存释放问题。而  __weak 代表一种非拥有关系，weakSelf 和 _loadData 之间不会形成相互引用。

上面的例子中，引用问题由原来的

>self 持有 _object， _object 持有 block，block 持有 self

变成：

>self 持有 _object， _object 持有 block

所以就没有相互引用的问题了。

那这个 strongSelf 又是怎么回事呢？

因为 weakSelf 指向的是 self，而 self 是随时有可能被释放的，尤其是 block 通常执行在并发环境中。所以我们需要再次创建一个指向 weakSelf 的 strongSelf，如果想防止 weakSelf 被释放，例如当 block 回调是在子线程，block 执行的时候，主线程可能在 block 执行到一半的时候就将 self 置空，所以可以再次强引用一次。

我们举个例子来说明为什么 self 可能会被释放。假设 JJMemoryViewController push 到 JJTestMemoryViewController，JJTestMemoryViewController 执行 Block 如下：

```
#import "JJTestMemoryViewController.h"
@interface JJTestMemoryViewController ()
@property (nonatomic, copy) void(^block)();
@end

@implementation JJTestMemoryViewController

- (void)viewDidLoad{
    self.title = @"B 界面 ";
    __weak typeof(self) weakSelf = self;
    self.block = ^{
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            NSLog(@"%@", weakSelf.title);
        });
    };
    self.block();
}
@end
```

如果 JJTestMemoryViewController 10 秒之后返回, JJMemoryViewController 界面会正常打印 weakSelf.title.
但如果 JJTestMemoryViewController 10 秒之内返回 JJTestMemoryViewController 则会打印 null，因为 10 秒之内返回，JJTestMemoryViewController 界面执行 dealloc 销毁，内存提前销毁，JJTestMemoryViewController 界面对应的 self 不存在，因此也不可能执行关于 self 的事项。所以需要使用 strongSelf 。

```
- (void)viewDidLoad{
    self.title = @"B 界面 ";
    __weak typeof(self) weakSelf = self;
    self.block = ^{
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        	__strong typeof(self) strongSelf = weakSelf;
            NSLog(@"%@", strongSelf);
        });
    };
    self.block();
}
```

而如果具有 strongSelf，会使 B 界面所对应的 self 引用计数+1，即使 10 秒内返回 A 界面， B 界面也不会立刻释放。并且 strongSelf 属于局部变量，存在与栈中，会随着 Block 的执行而销毁。
总之 strongSelf 就是为了保证 Block 中的事件执行正确。

#### performSelector

performSelector 有以下的 API：

```
- (id)performSelector:(SEL)aSelector;
- (id)performSelector:(SEL)aSelector withObject:(id)object;
- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;
```
它的用法其实就是一个对象调用一个方法（Objective-C 中方法被定义为 SEL 类型），例如下面的两种写法是等价的：
```
[object methodName];
[object performSelector:@selector(methodName)];
```
因为这两种写法是等效的关系，我们通常不会用 performSelector 来取代普通的方法调用。performSelector 的好处是可以在运行时决定调用的 SEL，同时，SEL 是由一个 NSString 初始化的，甚至，对象也可以用 NSString 初始化而成。所以，利用这种特性，我们可以做一些对象和方法的动态转发，例如下面的例子：

```
- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params{
    NSString *targetClassString = [NSString stringWithFormat:@"Target_%@", targetName];
    NSString *actionString = [NSString stringWithFormat:@"Action_%@:", actionName];
    Class targetClass = NSClassFromString(targetClassString);
    id target = [[targetClass alloc] init];
    SEL action = NSSelectorFromString(actionString);
    if (target == nil) {
        // 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的
        return nil;
    }
    if ([target respondsToSelector:action]) {
        return [target performSelector:action withObject:params];
    } else {
        // 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理
        SEL action = NSSelectorFromString(@"notFound:");
        if ([target respondsToSelector:action]) {
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
            return [target performSelector:action withObject:params];
#pragma clang diagnostic pop
        } else {
            // 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。
            return nil;
        }
    }
}
```
> 从上面的代码你应该可以猜到常用的热更新方法是怎么实现的吧。

你会发现上面的代码中有这样一个东西：
```
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
            //XXXXX
#pragma clang diagnostic pop
```
为什么呢，因为不加这段代码的话你会发现如下的警告：

![](https://ws3.sinaimg.cn/large/006tNc79gy1fge8laxu1fj30fh02pwec.jpg)

它告诉我们，这里的写法可能会导致内存泄漏。我们用一段更简洁的代码来解释为什么会有这段警告：

JJMemoryObject.h
```
@interface JJMemoryObject : NSObject<NSCopying>

- (NSNumber *)copyOne:(NSNumber *)number;
- (NSNumber *)addOne:(NSNumber *)number;

@end
```

JJMemoryObject.m
```
- (NSNumber *)copyOne:(NSNumber *)number{
    NSNumber *returnNumber = [number copy];
    return returnNumber;
}

- (NSNumber *)addOne:(NSNumber *)number{
    NSNumber *returnNumber = @(number.integerValue + 1);
    return returnNumber;
}
```

```
#import "JJMemoryViewController.h"
#import "JJMemoryObject.h"

@implementation JJMemoryViewController{
    JJMemoryObject *_object;
}

- (void)viewDidLoad{
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor whiteColor];
    _object = [JJMemoryObject new];
    [self testPerformSelector];
}

- (void)testPerformSelector{
    NSNumber *number = @2;
    //如果这么写的话就有问题
    [_object performSelector:@selector(copyOne:) withObject:nil];
}
```
你可以试下写下上面的代码，你会发现编译器发出一个错误提示：

![](https://ws4.sinaimg.cn/large/006tNbRwgy1fghd0p7zluj30gp00zjr8.jpg)

因为使用 performSelector: 这个方法的话，编译器不会为你添加释放操作，而以 copy 开头的方法是会 retain 一个返回的值的，这时候又没有相应的 release 操作，所以导致了内存泄漏。（为什么不会 release 呢，因为 performSelector 这个方法所调用的 selector 可能是动态的，所以它不了解方法签名和返回值，甚至是否有返回值都不懂，所以编译器无法用 ARC 的内存管理规则来判断返回值是否应该释放。因此，ARC 采用了比较谨慎的做法，不添加释放操作）。

你可能会想，既然有错误提示，那我们在出现错误提示时修改代码不就可以了吗？看看下面的写法：

```
SEL selector = number.integerValue > 1?@selector(copyOne:):@selector(addOne:);
_object = [_object performSelector:selector withObject:number];
```

这时候没有编译器错误提示了！因为 selector 时在运行时才能确定的，所以编译器无法确定哪个方法会被真正调用，所以没有错误提示，于是，当你自信地写下如上代码时，就有可能会引发内存泄漏。

如上面的代码，，即在方法返回对象时就可能将其持有，从而可能导致内存泄露。

#### NSNotificationcenter

NSNotificationcenter 其实不会有循环引用的问题，例如我们这里写：

```
- (void)registNotification{
    [[NSNotificationCenter defaultCenter] addObserverForName:@"JJMemoryViewControllerNotification"
                                                      object:nil
                                                       queue:[NSOperationQueue mainQueue]
                                                  usingBlock:^(NSNotification * notification) {
                                                      self.title = notification.userInfo[@"title"];
                                                  }];
}
```
这里只有单向的强引用。

只有这么写才会有循环引用的问题：

```
__weak __typeof__(self) weakSelf = self;
 _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"testKey"
                                                               object:nil
                                                                queue:nil
                                                           usingBlock:^(NSNotification *note) {
     __typeof__(self) strongSelf = weakSelf;
     [strongSelf dismissModalViewControllerAnimated:YES];
 }];
```

NSNotificationcenter 需要注意的是解除监听的问题：

```
[[NSNotificationCenter defaultCenter] removeObserver:self];
```
这个比较常见，如果你在 viewWillAppear 中监听了一个 NSNotificationcenter，记得在 viewWillDisappear 中调用 removeObserver。同样的，如果你在 viewDidLoad 监听了一个 NSNotificationcenter，记得在 dealloc 中调用 removeObserver。 

为什么说需要注意呢，当你的类本来有内存泄漏的时候，你的类很可能不会调用 dealloc 方法，所以你在 dealloc 中调用 removeObserver 可以说没什么卵用。

又或者，当你使用以下方法进行控制器的切换时：

```
+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;
```

viewWillDisappear 也不会调用，所以你想当然的想在 viewWillDisappear 中调用 removeObserver 也没什么卵用。所以我们必须确保 removeObserver 这个操作会真的执行。

#### NSTimer

在使用 NSTimer addtarget 时，为了防止 target 被释放而导致的程序异常，timer 会持有 self，所以这也是一处内存泄露的隐患。

看下面的例子：

```
@implementation JJMemoryViewController{
    NSTimer *_timer;
}

- (void)viewDidLoad{
    [super viewDidLoad];    
    _timer = [NSTimer scheduledTimerWithTimeInterval:3.0f
                                              target:self
                                            selector:@selector(timerFire:)
                                            userInfo:nil
                                             repeats:YES];
    [_timer fire];
}

-(void)timerFire:(id)userinfo {
    NSLog(@"\n A 界面");
}
@end
```
上面代码的引用关系为 self 强引用 _timer,  _timer 强引用 self（其中的 selector）。所以会造成内存泄漏，为了防止内存泄漏，我们在 可能会想到在 delloc 方法中调用 cleanTimer。

```
- (void)dealloc{
	[_timer invalidate];
    NSLog(@"JJMemoryViewController dealloc");
}
```
然而这并没有什么作用，因为 _timer 对象并没有正常释放，所以 delloc 无法执行，定时器仍然在无限的执行下去。当前类销毁执行 dealloc 的前提是定时器需要停止并滞空，而定时器停止并滞空的时机在当前类调用 dealloc 方法时，这样就造成了互相等待的场景，从而内存一直无法释放。

所以，如何解决？

如果将 _timer 设置为 weak 可以解决吗？

```
@implementation JJMemoryViewController{
    NSTimer __weak *_timer;
}
```

不可以。因为这个 _timer 实际上是由 RunLoop 持有的，我们上面说的 “self 强引用 _timer,  _timer 强引用 self” 并不准确。所以将 _timer 设置为 weak 并不能解决问题。

<div class="tip">
我们上面的写法 timer 会被默认注册到 NSDefaultRunLoopMode 模式的 RunLoop 中，这个点需要注意，因为 RunLoop 只能运行在一种mode下，如果要换 mode，当前的 loop 也需要停下重启成新的。
   
利用这个机制，ScrollView 滚动过程中 NSDefaultRunLoopMode 的 mode 会切换到 UITrackingRunLoopMode 来保证 ScrollView 的流畅滑动, 只能在 NSDefaultRunLoopMode 模式下处理的事件会影响ScrollView的滑动。
   
如果我们把一个 NSTimer 对象以 NSDefaultRunLoopMode 添加到主运行循环中的时候, ScrollView 滚动过程中会因为 mode 的切换，而导致 NSTimer 将不再被调度。
所以正确的方式是这么写：

[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes];
</div>

方案1: 可以在 `viewDidDisappear` 或 `viewWillDisappear` 做如下操作：

```
- (void)viewWillDisappear:(BOOL)animated{
    [super viewWillDisappear:animated];
    [_timer invalidate];
}
```
或者 cleanTimer 方法外漏，在外部调用。

```
- (void)cleanTime{
    [_timer invalidate];
}
```

可是并不是特别优雅，要是其他开发者忘记调用 cleanTimer，或者 `viewDidDisappear` 或 `viewWillDisappear` 没有被正确调用到， 这个类就会一直存在内存泄漏，然后定时器也不会停止。

方案2: 将 _timer 对 selector 的强引用转移到 block:

```
+ (NSTimer *)jj_scheduledTimerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats{
    void (^block)() = [inBlock copy];
    NSTimer * timer = [self scheduledTimerWithTimeInterval:inTimeInterval target:self selector:@selector(__executeTimerBlock:) userInfo:block repeats:inRepeats];
    return timer;
}

+ (NSTimer *)jj_timerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats{
    void (^block)() = [inBlock copy];
    NSTimer * timer = [self timerWithTimeInterval:inTimeInterval target:self selector:@selector(__executeTimerBlock:) userInfo:block repeats:inRepeats];
    return timer;
}

+ (void)__executeTimerBlock:(NSTimer *)inTimer;{
    if([inTimer userInfo]){//相当于 if(block)
        void (^block)() = (void (^)())[inTimer userInfo];
        block();
    }
}
```

调用：
```
_timer = [NSTimer jj_scheduledTimerWithTimeInterval:1 block:^{
        NSLog(@"\n A 界面");
    } repeats:YES];
[_timer fire];
```

这样的话 _timer 和 self 之间就没有了强引用，（因为没有 targer 了，targer 被转移到 NSTimer 身上了）问题解决。对 block 执行 copy 是因为防止等下执行的时候，block 无效了。

方案3: 推荐用 dispatch 的 timer：

基于 GCD 的，并且不受 runLoop 的影响，对 target 是 weak 引用，不会引起循环引用的问题，总是在主线程调用。
具体可以参考 [YYTimer](https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYTimer.m>)


#### 非 OC 对象内存处理

对于一些非 OC 对象，使用完毕后其内存仍需要我们手动释放。举个例子，比如常用的滤镜操作调节图片亮度：
```
CIImage *beginImage = [[CIImage alloc]initWithImage:[UIImage imageNamed:@"yourname.jpg"]];
CIFilter *filter = [CIFilter filterWithName:@"CIColorControls"];
[filter setValue:beginImage forKey:kCIInputImageKey];
[filter setValue:[NSNumber numberWithFloat:.5] forKey:@"inputBrightness"];// 亮度-1~1
CIImage *outputImage = [filter outputImage];
//GPU 优化
EAGLContext * eaglContext = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];
eaglContext.multiThreaded = YES;
CIContext *context = [CIContext contextWithEAGLContext:eaglContext];
[EAGLContext setCurrentContext:eaglContext];

CGImageRef ref = [context createCGImage:outputImage fromRect:outputImage.extent];
UIImage *endImg = [UIImage imageWithCGImage:ref];
_imageView.image = endImg;
CGImageRelease(ref);// 非 OC 对象需要手动内存释放
```
在如上代码中的 CGImageRef 类型变量非 OC 对象，其需要手动执行释放操作 CGImageRelease(ref)，否则会造成大量的内存泄漏导致程序崩溃。其他的对于 CoreFoundation 框架下的某些对象或变量需要手动释放、C 语言代码中的 malloc 等需要对应 free 等都需要注意。

#### 代理未清空引起野指针

iOS 的某些 API，或者你使用一些年代比较久远的第三方库，其 delegate 声明为 assign 的，(__weak 在 iOS5 之后才出现)。这样就会引起野指针的问题，可能会引起一些莫名其妙的 crash。当一个对象被回收时，对应的 delegate 实体也就被回收，但是 delegate 的指针确没有被 nil，从而就变成了游荡的野指针了。所以在 delloc 方法中要将对应的 assign 代理设置为 nil，如：

```
- (void)dealloc{
	self.XXX.delegate = nil;
}
```

### 检测内存泄漏

#### 借助 Xcode 自带的 Instruments 工具（选取真机测试）

![](https://ws1.sinaimg.cn/large/006tNc79gy1fj7jq7zf43j30yg0i7wfq.jpg)
 
 这种检测方法存在各种问题和不便：
  
- 首先，你得打开 Allocations
- 其次，你得一个个场景去重复的操作
- 无法及时得知泄露，得专门做一遍上述操作，十分繁琐

  所以通常我都不会使用，所以具体就不展开。

#### 重写 dealloc 方法

简单暴力的重写 dealloc 方法，加入断点或打印判断某类是否正常释放。

dealloc 调用方式如下： 如果 a 持有对象 b ，b 持有 c， c 持有 d， 假设 a 是一个 vc(其实只要是个对象都是一样的) 这时候 a.navigationxxxx popviewcon......  这时候如果 a “本身”没有内存泄漏，dealloc 回正常执行，
但在执行 dealloc 的，a 会驱使 b 释放，b 如果没有泄漏会执行 b 的 delloc 然后 b 在 dealloc 执行完之前首先驱使 c 释放，c 如果没有泄漏，在 c 的 dealloc 执行完之前会首先驱使 d 释放。这是整个释放链。

我们现在假设 a 确实没内存泄漏，但是 b 有，则 b 的 delloc 不会执行，这样 c、d 的也不会执行，你就会看到，a 的 delloc 执行了，但是 它所持有的 b， b 持有的 c， c 持有的 d 都没有释放。

因此 单纯以一个 delloc 来确定我整个类释放了是不准确的，你要保证你这个对象所有所持有的对象（系统对象应该不与考虑，即使你考虑了 系统控件／对象造成的对象你也解决不了）都执行了 delloc 方法，你才可以保证的说：没有内存泄漏了。

#### 使用 微信阅读开源的 MLeaksFinder

具体介绍可看 [MLeaksFinder](https://wereadteam.github.io/2016/02/22/MLeaksFinder/)


#### Facebook 开源 的 FBRetainCycleDetector 。

<https://github.com/facebook/FBRetainCycleDetector>


